exec("""\nA1='ignore'\nA0=EOFError\nz=float\nq='.jpeg'\np='rb'\no=bin\nn=str\nl='.txt'\nk='.jpg'\nj='utf-8'\ni=input\nh=list\na='B'\nZ=False\nW='wb'\nV=True\nU=print\nT=ValueError\nR='slow'\nQ='0'\nP=sum\nO='1'\nM=''\nL=min\nK=open\nJ=max\nI=Exception\nH=int\nG=bytearray\nF=bytes\nE=None\nD=b''\nC=range\nA=len\nimport os as N,sys,math as r,struct as b,array,random as S,heapq as c,binascii as X,logging as B,paq as d,zlib as e,time\nfrom datetime import datetime as f\nfrom typing import List,Dict,Tuple,Optional,Union\nfrom enum import Enum as s\nfrom mpmath import mp\nB.basicConfig(level=B.INFO,format='%(asctime)s - %(levelname)s - %(message)s')\nAH='PAQJP_6'\nAI=9\nAJ=1<<15\nA2=1024\nm='pi_digits.txt'\nt=[A for A in C(2,256)if all(A%B!=0 for B in C(2,H(A**.5)+1))]\ndef u(digits,filename=m):\n	D=digits;C=filename\n	try:\n		with K(C,'w')as E:E.write(','.join(n(A)for A in D))\n		B.info(f"Successfully saved {A(D)} base-10 pi digits to {C}");return V\n	except I as F:B.error(f"Failed to save base-10 pi digits to {C}: {F}");return Z\ndef A3(filename=m,expected_count=3):\n	G=expected_count;C=filename\n	try:\n		if not N.path.isfile(C):B.warning(f"Base-10 pi digits file {C} does not exist");return\n		with K(C,'r')as L:\n			J=L.read().strip()\n			if not J:B.warning(f"Base-10 pi digits file {C} is empty");return\n			D=[]\n			for E in J.split(','):\n				if not E.isdigit():B.warning(f"Invalid integer in {C}: {E}");return\n				F=H(E)\n				if not 0<=F<=255:B.warning(f"Digit out of range in {C}: {F}");return\n				D.append(F)\n			if A(D)!=G:B.warning(f"Loaded {A(D)} digits, expected {G}");return\n			B.info(f"Successfully loaded {A(D)} base-10 pi digits from {C}");return D\n	except I as M:B.error(f"Failed to load base-10 pi digits from {C}: {M}");return\ndef A4(num_digits=3,filename=m):\n	F=filename;C=num_digits;J=A3(F,C)\n	if J is not E:return J\n	try:\n		mp.dps=C;D=[H(A)for A in mp.pi.digits(10)[0]]\n		if A(D)!=C:B.error(f"Generated {A(D)} digits, expected {C}");raise T('Incorrect number of pi digits generated')\n		if not all(0<=A<=9 for A in D):B.error('Generated pi digits contain invalid values');raise T('Invalid pi digits generated')\n		K=[A*255//9%256 for A in D];u(K,F);return K\n	except I as L:B.error(f"Failed to generate base-10 pi digits: {L}");M=[3,1,4];G=[A*255//9%256 for A in M[:C]];B.warning(f"Using {A(G)} fallback base-10 digits");u(G,F);return G\nA5=A4(3)\ndef A6(filename):\n	A=filename\n	try:C=N.path.getctime(A);return f.fromtimestamp(C)\n	except I as D:B.error(f"Failed to get creation time for {A}: {D}");return f.now()\ndef A7(filename,dt):\n	A=filename\n	try:C=H(dt.timestamp());N.utime(A,(C,C));B.info(f"Set creation/modification time of {A} to {dt}")\n	except I as D:B.error(f"Failed to set creation time for {A}: {D}")\nclass Y(s):DEFAULT=0;JPEG=1;EXE=2;TEXT=3\nclass AK(s):COMPRESS=0;DECOMPRESS=1\nclass AL:\n	def __init__(A,s=M):A.data=G(s.encode(j))\n	def resize(B,new_size):\n		C=new_size\n		if C>A(B.data):B.data+=G(C-A(B.data))\n		else:B.data=B.data[:C]\n	def size(B):return A(B.data)\n	def c_str(A):return A.data.decode(j,errors=A1)\n	def __iadd__(A,s):A.data+=s.encode(j);return A\n	def __getitem__(A,index):return A.data[index]\n	def __setitem__(A,index,value):A.data[index]=value\n	def __str__(A):return A.data.decode(j,errors=A1)\nclass v:\n	def __init__(A,size=0,initial_value=0):A.data=array.array(a,[initial_value]*size)\n	def resize(B,new_size):\n		C=new_size\n		if C>A(B.data):B.data.extend([0]*(C-A(B.data)))\n		else:B.data=B.data[:C]\n	def size(B):return A(B.data)\n	def __getitem__(A,index):return A.data[index]\n	def __setitem__(A,index,value):A.data[index]=value\n	def __len__(B):return A(B.data)\nclass A8:\n	def __init__(A,size=0):A.size_=size;A.data=v(size);A.pos=0\n	def setsize(B,size):\n		A=size\n		if A>0 and A&A-1==0:B.size_=A;B.data.resize(A)\n	def __getitem__(A,index):return A.data[index&A.size_-1]\n	def __call__(A,i):return A.data[A.pos-i&A.size_-1]\n	def size(A):return A.size_\nAM=A8()\nclass w:\n	def __init__(A,left=E,right=E,symbol=E):A.left=left;A.right=right;A.symbol=symbol\n	def is_leaf(A):return A.left is E and A.right is E\nclass A9:\n	def __init__(A):A.table=[[1,2,0,0],[3,5,1,0],[4,6,0,1],[7,10,2,0],[8,12,1,1],[9,13,1,1],[11,14,0,2],[15,19,3,0],[16,23,2,1],[17,24,2,1],[18,25,2,1],[20,27,1,2],[21,28,1,2],[22,29,1,2],[26,30,0,3],[31,33,4,0],[32,35,3,1],[32,35,3,1],[32,35,3,1],[32,35,3,1],[34,37,2,2],[34,37,2,2],[34,37,2,2],[34,37,2,2],[34,37,2,2],[34,37,2,2],[36,39,1,3],[36,39,1,3],[36,39,1,3],[36,39,1,3],[38,40,0,4],[41,43,5,0],[42,45,4,1],[42,45,4,1],[44,47,3,2],[44,47,3,2],[46,49,2,3],[46,49,2,3],[48,51,1,4],[48,51,1,4],[50,52,0,5],[53,43,6,0],[54,57,5,1],[54,57,5,1],[56,59,4,2],[56,59,4,2],[58,61,3,3],[58,61,3,3],[60,63,2,4],[60,63,2,4],[62,65,1,5],[62,65,1,5],[50,66,0,6],[67,55,7,0],[68,57,6,1],[68,57,6,1],[70,73,5,2],[70,73,5,2],[72,75,4,3],[72,75,4,3],[74,77,3,4],[74,77,3,4],[76,79,2,5],[76,79,2,5],[62,81,1,6],[62,81,1,6],[64,82,0,7],[83,69,8,0],[84,76,7,1],[84,76,7,1],[86,73,6,2],[86,73,6,2],[44,59,5,3],[44,59,5,3],[58,61,4,4],[58,61,4,4],[60,49,3,5],[60,49,3,5],[76,89,2,6],[76,89,2,6],[78,91,1,7],[78,91,1,7],[80,92,0,8],[93,69,9,0],[94,87,8,1],[94,87,8,1],[96,45,7,2],[96,45,7,2],[48,99,2,7],[48,99,2,7],[88,101,1,8],[88,101,1,8],[80,102,0,9],[103,69,10,0],[104,87,9,1],[104,87,9,1],[106,57,8,2],[106,57,8,2],[62,109,2,8],[62,109,2,8],[88,111,1,9],[88,111,1,9],[80,112,0,10],[113,85,11,0],[114,87,10,1],[114,87,10,1],[116,57,9,2],[116,57,9,2],[62,119,2,9],[62,119,2,9],[88,121,1,10],[88,121,1,10],[90,122,0,11],[123,85,12,0],[124,97,11,1],[124,97,11,1],[126,57,10,2],[126,57,10,2],[62,129,2,10],[62,129,2,10],[98,131,1,11],[98,131,1,11],[90,132,0,12],[133,85,13,0],[134,97,12,1],[134,97,12,1],[136,57,11,2],[136,57,11,2],[62,139,2,11],[62,139,2,11],[98,141,1,12],[98,141,1,12],[90,142,0,13],[143,95,14,0],[144,97,13,1],[144,97,13,1],[68,57,12,2],[68,57,12,2],[62,81,2,12],[62,81,2,12],[98,147,1,13],[98,147,1,13],[100,148,0,14],[149,95,15,0],[150,107,14,1],[150,107,14,1],[108,151,1,14],[108,151,1,14],[100,152,0,15],[153,95,16,0],[154,107,15,1],[108,155,1,15],[100,156,0,16],[157,95,17,0],[158,107,16,1],[108,159,1,16],[100,160,0,17],[161,105,18,0],[162,107,17,1],[108,163,1,17],[110,164,0,18],[165,105,19,0],[166,117,18,1],[118,167,1,18],[110,168,0,19],[169,105,20,0],[170,117,19,1],[118,171,1,19],[110,172,0,20],[173,105,21,0],[174,117,20,1],[118,175,1,20],[110,176,0,21],[177,105,22,0],[178,117,21,1],[118,179,1,21],[120,184,0,23],[185,115,24,0],[186,127,23,1],[128,187,1,23],[120,188,0,24],[189,115,25,0],[190,127,24,1],[128,191,1,24],[120,192,0,25],[193,115,26,0],[194,127,25,1],[128,195,1,25],[120,196,0,26],[197,115,27,0],[198,127,26,1],[128,199,1,26],[120,200,0,27],[201,115,28,0],[202,127,27,1],[128,203,1,27],[120,204,0,28],[205,115,29,0],[206,127,28,1],[128,207,1,28],[120,208,0,29],[209,125,30,0],[210,127,29,1],[128,211,1,29],[130,212,0,30],[213,125,31,0],[214,137,30,1],[138,215,1,30],[130,216,0,31],[217,125,32,0],[218,137,31,1],[138,219,1,31],[130,220,0,32],[221,125,33,0],[222,137,32,1],[138,223,1,32],[130,224,0,33],[225,125,34,0],[226,137,33,1],[138,227,1,33],[130,228,0,34],[229,125,35,0],[230,137,34,1],[138,231,1,34],[130,232,0,35],[233,125,36,0],[234,137,35,1],[138,235,1,35],[130,236,0,36],[237,125,37,0],[238,137,36,1],[138,239,1,36],[130,240,0,37],[241,125,38,0],[242,137,37,1],[138,243,1,37],[130,244,0,38],[245,135,39,0],[246,137,38,1],[138,247,1,38],[140,248,0,39],[249,135,40,0],[250,69,39,1],[80,251,1,39],[140,252,0,40],[249,135,41,0],[250,69,40,1],[80,251,1,40],[140,252,0,41]]\n	def nex(A,state,sel):return A.table[state][sel]\nAN=A9()\ndef AA(dt=E):\n	A=dt\n	if A is E:A=f.now()\n	J=A.second;K=A.minute;L=A.hour;M=A.weekday();H=A.month;N=A.day;I=A.year;D=0\n	if not(0<=J<=59 and 0<=K<=59 and 0<=L<=23 and 0<=M<=6 and 1<=H<=12 and 1<=N<=31 and 0<=I<=4095 and 0<=D<=127):B.error('Invalid date/time values for encoding');raise T('Date/time values out of range')\n	C=G(6);C[0]=J&63|(D&3)<<6;C[1]=K&63|(D>>2&3)<<6;C[2]=L&31|(H&7)<<5;C[3]=H>>3&1|(N&31)<<1|(D>>4&3)<<6;C[4]=M&7|(I&31)<<3;C[5]=I>>5&127|(D>>6&1)<<7;return F(C)\ndef x(data):\n	L='Decoded date/time values out of range';C=data\n	if A(C)<6:B.error('Insufficient data for datetime decoding');raise T('Data too short for datetime decoding')\n	D=C[0]&63;E=C[1]&63;F=C[2]&31;G=C[2]>>5&7|(C[3]&1)<<3;H=C[3]>>1&31;I=C[4]&7;J=C[4]>>3&31|(C[5]&127)<<5;K=C[0]>>6&3|(C[1]>>6&3)<<2|(C[3]>>6&3)<<4|(C[5]>>7&1)<<6\n	if not(0<=D<=59 and 0<=E<=59 and 0<=F<=23 and 0<=I<=6 and 1<=G<=12 and 1<=H<=31 and 0<=J<=4095 and 0<=K<=127):B.error(L);raise T(L)\n	return D,E,F,I,G,H,J,K\ndef AB(data,repeat=100):\n	B=G(data)\n	for D in t:\n		E=D if D==2 else J(1,r.ceil(D*4096/28672))\n		for I in C(repeat):\n			for H in C(0,A(B),3):B[H]^=E\n	return F(B)\ndef AC(data,chunk_size=4):\n	B=chunk_size;D=G()\n	for E in C(0,A(data),B):H=data[E:E+B];D.extend([A^255 for A in H])\n	return F(D)\ndef y(n):\n	if n<2:return Z\n	if n==2:return V\n	if n%2==0:return Z\n	for A in C(3,H(n**.5)+1,2):\n		if n%A==0:return Z\n	return V\ndef g(n):\n	A=0\n	while V:\n		if y(n-A):return n-A\n		if y(n+A):return n+A\n		A+=1\ndef quit(message=E):\n	A=message\n	if A:U(A)\n	sys.exit(1)\ndef AO(x):\n	if x<0:return 0\n	A=0\n	while x>0:x>>=1;A+=1\n	return A\ndef AD(d,n=12,repeat=1000):\n	B=(1<<n)-1;A=d\n	for E in C(repeat):\n		if A>2047:A=B\n		if A<-2047:A=0\n		D=(1<<n)/(1+r.exp(-A/512.));A=H(D);A=L(J(A,0),B)\n	return A\ndef AP(p):\n	A=v(4096);B=0\n	for D in C(-2047,2048):\n		E=AD(D)\n		for F in C(B,E+1):A[F]=D\n		B=E+1\n	A[4095]=2047;return A[p]\ndef hash(*B):C=B[0]*200002979+B[1]*30005491+(B[2]if A(B)>2 else 4294967295)*50004239+(B[3]if A(B)>3 else 4294967295)*70004807+(B[4]if A(B)>4 else 4294967295)*110002499;return C^C>>9^B[0]>>2^B[1]>>3^(B[2]if A(B)>2 else 0)>>4^(B[3]if A(B)>3 else 0)>>5^(B[4]if A(B)>4 else 0)>>6\nclass AE:\n	def __init__(A):A.compressor=E;A.PRIMES=t;A.PI_DIGITS=A5;A.seed_tables=A.generate_seed_tables();A.max_intersections=28;A.SQUARE_OF_ROOT=2;A.ADD_NUMBERS=1;A.MULTIPLY=3\n	def generate_seed_tables(D,num_tables=126,table_size=256,min_val=5,max_val=255,seed=42):\n		S.seed(seed);A=[]\n		for E in C(num_tables):B=[S.randint(min_val,max_val)for A in C(table_size)];A.append(B)\n		return A\n	def get_seed(B,table_idx,value):\n		C=table_idx\n		if 0<=C<A(B.seed_tables):return B.seed_tables[C][value%A(B.seed_tables[C])]\n		return 0\n	def binary_to_file(O,binary_data,filename):\n		F=filename;E=binary_data\n		try:\n			if not E:\n				B.warning(f"Empty binary data, writing empty file to {F}")\n				with K(F,W)as G:G.write(D)\n				return V\n			J=H(E,2);L=(A(E)+7)//8;C='%0*x'%(L*2,J)\n			if A(C)%2!=0:C=Q+C\n			M=X.unhexlify(C)\n			with K(F,W)as G:G.write(M)\n			return V\n		except I as N:B.error(f"Error saving file: {n(N)}");return Z\n	def file_to_binary(J,filename):\n		D=filename\n		try:\n			with K(D,p)as E:\n				C=E.read()\n				if not C:B.warning(f"Empty file {D}, returning empty binary string");return M\n				F=o(H(X.hexlify(C),16))[2:].zfill(A(C)*8);return F\n		except I as G:B.error(f"Error reading file: {n(G)}");return\n	def calculate_frequencies(E,binary_str):\n		C=binary_str\n		if not C:B.warning('Empty binary string, returning empty frequencies');return{}\n		A={}\n		for D in C:A[D]=A.get(D,0)+1\n		return A\n	def build_huffman_tree(J,frequencies):\n		D=frequencies\n		if not D:B.warning('No frequencies provided, returning None for Huffman tree');return\n		C=[(B,w(symbol=A))for(A,B)in D.items()];c.heapify(C)\n		while A(C)>1:E,F=c.heappop(C);G,H=c.heappop(C);I=w(left=F,right=H);c.heappush(C,(E+G,I))\n		return C[0][1]\n	def generate_huffman_codes(F,root,current_code=M,codes={}):\n		D=current_code;C=codes;A=root\n		if A is E:B.warning('Huffman tree is None, returning empty codes');return{}\n		if A.is_leaf():C[A.symbol]=D or Q;return C\n		if A.left:F.generate_huffman_codes(A.left,D+Q,C)\n		if A.right:F.generate_huffman_codes(A.right,D+O,C)\n		return C\n	def compress_data_huffman(C,binary_str):\n		D=binary_str\n		if not D:B.warning('Empty binary string, returning empty compressed string');return M\n		G=C.calculate_frequencies(D);F=C.build_huffman_tree(G)\n		if F is E:return M\n		A=C.generate_huffman_codes(F)\n		if Q not in A:A[Q]=Q\n		if O not in A:A[O]=O\n		H=M.join(A[B]for B in D);return H\n	def decompress_data_huffman(C,compressed_str):\n		D=compressed_str\n		if not D:B.warning('Empty compressed string, returning empty decompressed string');return M\n		I=C.calculate_frequencies(D);F=C.build_huffman_tree(I)\n		if F is E:return M\n		J=C.generate_huffman_codes(F);G={B:A for(A,B)in J.items()};H=M;A=M\n		for K in D:\n			A+=K\n			if A in G:H+=G[A];A=M\n		return H\n	def compress_data_zlib(E,data_bytes):\n		A=data_bytes\n		if not A:B.warning('Empty data bytes, returning empty compressed data');return D\n		try:return e.compress(A)\n		except e.error as C:B.error(f"zlib compression error: {C}");return\n	def decompress_data_zlib(E,compressed_data):\n		A=compressed_data\n		if not A:B.warning('Empty compressed data, returning empty decompressed data');return D\n		try:return e.decompress(A)\n		except e.error as C:B.error(f"zlib decompression error: {C}");return\n	def transform_01(A,data,repeat=100):\n		if not data:B.warning('transform_01: Empty input data, returning empty bytes');return D\n		return AB(data,repeat=repeat)\n	def reverse_transform_01(A,data,repeat=100):\n		if not data:B.warning('reverse_transform_01: Empty input data, returning empty bytes');return D\n		return A.transform_01(data,repeat=repeat)\n	def transform_03(A,data):\n		if not data:B.warning('transform_03: Empty input data, returning empty bytes');return D\n		return AC(data)\n	def reverse_transform_03(A,data):\n		if not data:B.warning('reverse_transform_03: Empty input data, returning empty bytes');return D\n		return A.transform_03(data)\n	def transform_04(I,data,repeat=100):\n		if not data:B.warning('transform_04: Empty input data, returning empty bytes');return D\n		E=G(data)\n		for J in C(repeat):\n			for H in C(A(E)):E[H]=(E[H]-H%256)%256\n		return F(E)\n	def reverse_transform_04(I,data,repeat=100):\n		if not data:B.warning('reverse_transform_04: Empty input data, returning empty bytes');return D\n		E=G(data)\n		for J in C(repeat):\n			for H in C(A(E)):E[H]=(E[H]+H%256)%256\n		return F(E)\n	def transform_05(J,data,shift=3):\n		I=shift\n		if not data:B.warning('transform_05: Empty input data, returning empty bytes');return D\n		E=G(data)\n		for H in C(A(E)):E[H]=(E[H]<<I|E[H]>>8-I)&255\n		return F(E)\n	def reverse_transform_05(J,data,shift=3):\n		I=shift\n		if not data:B.warning('reverse_transform_05: Empty input data, returning empty bytes');return D\n		E=G(data)\n		for H in C(A(E)):E[H]=(E[H]>>I|E[H]<<8-I)&255\n		return F(E)\n	def transform_06(J,data,seed=42):\n		if not data:B.warning('transform_06: Empty input data, returning empty bytes');return D\n		S.seed(seed);H=h(C(256));S.shuffle(H);E=G(data)\n		for I in C(A(E)):E[I]=H[E[I]]\n		return F(E)\n	def reverse_transform_06(L,data,seed=42):\n		if not data:B.warning('reverse_transform_06: Empty input data, returning empty bytes');return D\n		S.seed(seed);I=h(C(256));S.shuffle(I);J=[0]*256\n		for(E,K)in enumerate(I):J[K]=E\n		H=G(data)\n		for E in C(A(H)):H[E]=J[H[E]]\n		return F(H)\n	def transform_07(I,data,repeat=100):\n		E=data\n		if not E:B.warning('transform_07: Empty input data, returning empty bytes');return D\n		K=G(E);N=A(I.PI_DIGITS);Q=A(E)/1024;O=L(10,J(1,H(Q)));B.info(f"transform_07: Using {O} cycles for {A(E)} bytes (base-256)");P=A(E)%N;I.PI_DIGITS=I.PI_DIGITS[P:]+I.PI_DIGITS[:P];R=A(E)%256\n		for M in C(A(K)):K[M]^=R\n		for T in C(O*repeat//10):\n			for M in C(A(K)):S=I.PI_DIGITS[M%N];K[M]^=S\n		return F(K)\n	def reverse_transform_07(I,data,repeat=100):\n		E=data\n		if not E:B.warning('reverse_transform_07: Empty input data, returning empty bytes');return D\n		K=G(E);N=A(I.PI_DIGITS);Q=A(E)/1024;O=L(10,J(1,H(Q)));B.info(f"reverse_transform_07: Using {O} cycles for {A(E)} bytes (base-256)")\n		for T in C(O*repeat//10):\n			for M in C(A(K)):R=I.PI_DIGITS[M%N];K[M]^=R\n		S=A(E)%256\n		for M in C(A(K)):K[M]^=S\n		P=A(E)%N;I.PI_DIGITS=I.PI_DIGITS[-P:]+I.PI_DIGITS[:-P];return F(K)\n	def transform_08(I,data,repeat=100):\n		E=data\n		if not E:B.warning('transform_08: Empty input data, returning empty bytes');return D\n		K=G(E);N=A(I.PI_DIGITS);Q=A(E)/1024;O=L(10,J(1,H(Q)));B.info(f"transform_08: Using {O} cycles for {A(E)} bytes (base-256)");P=A(E)%N;I.PI_DIGITS=I.PI_DIGITS[P:]+I.PI_DIGITS[:P];R=g(A(E)%256)\n		for M in C(A(K)):K[M]^=R\n		for T in C(O*repeat//10):\n			for M in C(A(K)):S=I.PI_DIGITS[M%N];K[M]^=S\n		return F(K)\n	def reverse_transform_08(I,data,repeat=100):\n		E=data\n		if not E:B.warning('reverse_transform_08: Empty input data, returning empty bytes');return D\n		K=G(E);N=A(I.PI_DIGITS);Q=A(E)/1024;O=L(10,J(1,H(Q)));B.info(f"reverse_transform_08: Using {O} cycles for {A(E)} bytes (base-256)")\n		for T in C(O*repeat//10):\n			for M in C(A(K)):R=I.PI_DIGITS[M%N];K[M]^=R\n		S=g(A(E)%256)\n		for M in C(A(K)):K[M]^=S\n		P=A(E)%N;I.PI_DIGITS=I.PI_DIGITS[-P:]+I.PI_DIGITS[:-P];return F(K)\n	def transform_09(I,data,repeat=100):\n		N=repeat;E=data\n		if not E:B.warning('transform_09: Empty input data, returning empty bytes');return D\n		K=G(E);O=A(I.PI_DIGITS);R=A(E)/1024;P=L(10,J(1,H(R)));B.info(f"transform_09: Using {P} cycles with {N} repeats for {A(E)} bytes (base-256)");Q=A(E)%O;I.PI_DIGITS=I.PI_DIGITS[Q:]+I.PI_DIGITS[:Q];S=g(A(E)%256);T=A(E)%A(I.seed_tables);U=I.get_seed(T,A(E))\n		for M in C(A(K)):K[M]^=S^U\n		for W in C(P*N//10):\n			for M in C(A(K)):V=I.PI_DIGITS[M%O];K[M]^=V^M%256\n		return F(K)\n	def reverse_transform_09(I,data,repeat=100):\n		N=repeat;E=data\n		if not E:B.warning('reverse_transform_09: Empty input data, returning empty bytes');return D\n		K=G(E);O=A(I.PI_DIGITS);R=A(E)/1024;P=L(10,J(1,H(R)));B.info(f"reverse_transform_09: Using {P} cycles with {N} repeats for {A(E)} bytes (base-256)")\n		for W in C(P*N//10):\n			for M in C(A(K)):S=I.PI_DIGITS[M%O];K[M]^=S^M%256\n		T=g(A(E)%256);U=A(E)%A(I.seed_tables);V=I.get_seed(U,A(E))\n		for M in C(A(K)):K[M]^=T^V\n		Q=A(E)%O;I.PI_DIGITS=I.PI_DIGITS[-Q:]+I.PI_DIGITS[:-Q];return F(K)\n	def transform_10(K,data,repeat=100):\n		O=repeat;D=data\n		if not D:B.warning('transform_10: Empty input data, returning empty bytes with n=0');return F([0])\n		M=G(D);Q=A(D)/1024;P=L(10,J(1,H(Q)));B.info(f"transform_10: Using {P} cycles with {O} repeats for {A(D)} bytes (base-256)");N=0\n		for I in C(A(D)-1):\n			if D[I]==88 and D[I+1]==49:N+=1\n		B.info(f"transform_10: Found {N} 'X1' sequences");E=(N*K.SQUARE_OF_ROOT+K.ADD_NUMBERS)//3*K.MULTIPLY;E=E%256;B.info(f"transform_10: Computed n = {E}")\n		for R in C(P*O//10):\n			for I in C(A(M)):M[I]^=E\n		return F([E])+F(M)\n	def reverse_transform_10(Q,data,repeat=100):\n		K=repeat;E=data\n		if A(E)<1:B.warning('reverse_transform_10: Data too short, returning empty bytes');return D\n		M=E[0];I=G(E[1:]);O=A(E)/1024;N=L(10,J(1,H(O)));B.info(f"reverse_transform_10: Using {N} cycles with {K} repeats for {A(E)} bytes (base-256), n = {M}")\n		for R in C(N*K//10):\n			for P in C(A(I)):I[P]^=M\n		return F(I)\n	def transform_11(T,data,repeat=100):\n		N=repeat;D=data\n		if not D:B.warning('transform_11: Empty input data, returning y=0 with no data');return b.pack(a,0)\n		O=C(1,256);K=E;L=E;M=z('inf');R=P(1 for A in D if A==0);B.info(f"transform_11: Testing {A(O)} y values for {A(D)} bytes with {N} repeats, {R} zero bytes")\n		for F in O:\n			H=G(D)\n			for U in C(N):\n				for Q in C(A(H)):H[Q]=(H[Q]+F+1)%256\n			try:\n				J=d.compress(H)\n				if J is E:B.warning(f"transform_11: Compression with y={F} returned None");continue\n				if A(J)<M:K=J;L=F;M=A(J)\n			except I as S:B.warning(f"transform_11: Compression with y={F} failed: {S}");continue\n		if K is E:B.error('transform_11: All compression attempts failed, returning original data with y=0');return b.pack(a,0)+D\n		B.info(f"transform_11: Selected y={L} with compressed size {M}");return b.pack(a,L)+K\n	def reverse_transform_11(S,data,repeat=100):\n		J=repeat;H=data\n		if A(H)<1:B.warning('reverse_transform_11: Data too short to contain y, returning empty bytes');return D\n		K=b.unpack(a,H[:1])[0];L=H[1:]\n		if not L:B.warning('reverse_transform_11: No compressed data after y, returning empty bytes');return D\n		try:\n			M=d.decompress(L)\n			if not M:B.warning('reverse_transform_11: Decompression returned empty data');return D\n		except I as O:B.error(f"reverse_transform_11: Decompression failed: {O}");return D\n		E=G(M);Q=P(1 for A in E if A==0);B.info(f"reverse_transform_11: Processing {A(E)} bytes with y={K}, {Q} zero bytes, {J} repeats")\n		for T in C(J):\n			for N in C(A(E)):E[N]=(E[N]-K-1)%256\n		R=P(1 for A in E if A==0);B.info(f"reverse_transform_11: Restored data, {R} zero bytes after transformation");return F(E)\n	def generate_transform_method(K,marker):\n		E=marker\n		def H(data,repeat=1000):\n			M=repeat;H=data\n			if not H:B.warning(f"transform_{E}: Empty input data, returning empty bytes");return D\n			I=G(H);K=A(H);P=J(2000,L(256000,K));N=K%P%256;B.info(f"transform_{E}: Using size_mod={N} for {K} bytes, repeat={M}")\n			for Q in C(M):\n				for O in C(A(I)):I[O]^=(N+O%256)%256\n			return F(I)\n		def I(data,repeat=1000):\n			M=repeat;H=data\n			if not H:B.warning(f"reverse_transform_{E}: Empty input data, returning empty bytes");return D\n			I=G(H);K=A(H);P=J(2000,L(256000,K));N=K%P%256;B.info(f"reverse_transform_{E}: Using size_mod={N} for {K} bytes, repeat={M}")\n			for Q in C(M):\n				for O in C(A(I)):I[O]^=(N+O%256)%256\n			return F(I)\n		return H,I\n	def paq_compress(A,data):\n		if not data:B.warning('paq_compress: Empty input data, returning empty bytes');return D\n		return d.compress(data)\n	def paq_decompress(A,data):\n		if not data:B.warning('paq_decompress: Empty input data, returning empty bytes');return D\n		return d.decompress(data)\n	def compress_with_best_method(G,data,filetype,input_filename,mode=R):\n		U=filetype;O=mode;J=data\n		if not J:B.warning('compress_with_best_method: Empty input data, returning minimal marker');return F([0])\n		d=A6(input_filename);V=AA(d);W=[(1,G.transform_04),(2,G.transform_01),(3,G.transform_03),(5,G.transform_05),(6,G.transform_06),(7,G.transform_07),(8,G.transform_08),(9,G.transform_09)];e=W+[(10,G.transform_10),(11,G.transform_11)]+[(A,G.generate_transform_method(A)[0])for A in C(12,256)];P=e if O==R else W\n		if U in[Y.JPEG,Y.TEXT]:\n			Z=[(7,G.transform_07),(8,G.transform_08),(9,G.transform_09)]\n			if O==R:Z+=[(10,G.transform_10),(11,G.transform_11)]+[(A,G.generate_transform_method(A)[0])for A in C(12,256)]\n			P=Z+[A for A in P if A[0]not in[7,8,9,10,11]+h(C(12,256))]\n		f=[('paq',G.paq_compress),('zlib',G.compress_data_zlib)];K=E;L=z('inf');M=E;Q=E\n		for(a,g)in P:\n			i=g(J)\n			for(b,j)in f:\n				try:\n					S=j(i)\n					if S is E:continue\n					c=A(S)\n					if c<L:L=c;K=S;M=a;Q=b\n				except I as k:B.warning(f"Compression method {b} with transform {a} failed: {k}");continue\n		if A(J)<A2:\n			l=o(H(X.hexlify(J),16))[2:].zfill(A(J)*8);T=G.compress_data_huffman(l);N=H(T,2).to_bytes((A(T)+7)//8,'big')if T else D\n			if N and A(N)<L:L=A(N);K=N;M=4;Q='huffman'\n		if K is E:B.error('All compression methods failed, returning original data with marker 0');return F([0])+V+J\n		B.info(f"Best compression method: {Q}, Marker: {M} for {U.name} in {O} mode");return F([M])+V+K\n	def decompress_with_best_method(F,data):\n		M=data\n		if A(M)<7:B.warning('decompress_with_best_method: Insufficient data, returning empty bytes');return D,E\n		G=M[0];V=M[1:7];N=M[7:]\n		try:W,Y,Z,a,b,c,d,e=x(V);B.info(f"Decoded datetime: {d}-{b:02d}-{c:02d} {Z:02d}:{Y:02d}:{W:02d}, Day of week: {a}, Version: {e}")\n		except T as J:B.error(f"Datetime decoding failed: {J}");return D,E\n		O={1:F.reverse_transform_04,2:F.reverse_transform_01,3:F.reverse_transform_03,5:F.reverse_transform_05,6:F.reverse_transform_06,7:F.reverse_transform_07,8:F.reverse_transform_08,9:F.reverse_transform_09,10:F.reverse_transform_10,11:F.reverse_transform_11};O.update({A:F.generate_transform_method(A)[1]for A in C(12,256)})\n		if G==4:\n			f=o(H(X.hexlify(N),16))[2:].zfill(A(N)*8);S=F.decompress_data_huffman(f)\n			if not S:B.warning('Huffman decompression returned empty string');return D,E\n			try:\n				g=(A(S)+7)//8;R='%0*x'%(g*2,H(S,2))\n				if A(R)%2!=0:R=Q+R\n				return X.unhexlify(R),E\n			except I as J:B.error(f"Error converting decompressed Huffman data: {J}");return D,E\n		if G not in O:B.error(f"Unknown compression method marker: {G}");return D,E\n		try:\n			K=F.paq_decompress(N)\n			if not K:B.warning('PAQ decompression returned empty data');return D,E\n			L=O[G](K);U=P(1 for A in L if A==0);B.info(f"Decompressed with marker {G}, {U} zero bytes in result");return L,G\n		except I as J:\n			B.warning(f"PAQ decompression failed: {J}. Trying zlib...");K=F.decompress_data_zlib(N)\n			if K is E:B.error('All decompression methods failed');return D,E\n			L=O[G](K);U=P(1 for A in L if A==0);B.info(f"Decompressed with marker {G} using zlib, {U} zero bytes in result");return L,G\ndef AF(filename):\n	B,A=N.path.splitext(filename.lower())\n	if A==k or A==q:return Y.JPEG\n	elif A==l:return Y.TEXT\n	else:return Y.DEFAULT\ndef AG():\n	a='2';U('PAQJP_6 Compression System with Base-10 Pi Transformation (3 digits)');U('Created by Jurijus Pacalovas.');U('Options:');U('1 - Compress file (PAQJP_6 with transformations and datetime)');U('2 - Decompress file (PAQJP_6 with transformations and datetime)');b=AE()\n	try:\n		L=i('Enter 1 or 2: ').strip()\n		if L not in(O,a):B.error('Invalid choice. Exiting.');return\n	except A0:B.info('No input detected. Defaulting to Compress (1).');L=O\n	M=R\n	if L==O:\n		try:\n			c=i('Enter compression mode (1 for fast, 2 for slow): ').strip()\n			if c==O:M='fast'\n			elif c==a:M=R\n			else:B.warning('Invalid mode choice. Defaulting to slow mode.');M=R\n		except A0:B.info('No mode input detected. Defaulting to slow mode.');M=R\n		B.info(f"Selected compression mode: {M}")\n	G=i('Input file name: ').strip();H=i('Output file name: ').strip()\n	if not N.path.isfile(G):B.error(f"Error: Input file '{G}' does not exist.");return\n	if N.path.getsize(G)==0 and L==O:\n		B.warning(f"Input file '{G}' is empty, writing empty output")\n		with K(H,W)as J:J.write(F([0]))\n		return\n	d=AF(G);B.info(f"Detected filetype: {d.name}")\n	if L==O:\n		with K(G,p)as T:Q=T.read()\n		V=b.compress_with_best_method(Q,d,G,mode=M)\n		if V is E:return\n		with K(H,W)as J:J.write(V)\n		X=N.path.getsize(G);S=A(V);g=S/X*100 if X>0 else 0;Y=P(1 for A in Q if A==0);B.info(f"Compression successful. Output saved to {H}. Size: {S} bytes, {Y} zero bytes in input");B.info(f"Original: {X} bytes, Compressed: {S} bytes, Ratio: {g:.2f}%")\n	elif L==a:\n		with K(G,p)as T:Q=T.read()\n		if not Q:\n			B.warning(f"Input file '{G}' is empty, writing empty output")\n			with K(H,W)as J:J.write(D)\n			return\n		try:\n			Z,j=b.decompress_with_best_method(Q)\n			if Z is E:return\n			e=N.path.splitext(G)[1].lower()\n			if j in[7,8,9,10,11]+h(C(12,256))and not H.endswith((k,q,l)):\n				if e in[k,q]:H+=k\n				elif e==l:H+=l\n			with K(H,W)as J:J.write(Z)\n			m=Q[1:7];n,o,r,z,s,t,u,A1=x(m);v=f(u,s,t,r,o,n);A7(H,v);S=N.path.getsize(G);w=N.path.getsize(H);Y=P(1 for A in Z if A==0);B.info(f"Decompression successful. Output saved to {H}, {Y} zero bytes in output");B.info(f"Compressed: {S} bytes, Decompressed: {w} bytes")\n		except I as y:B.error(f"Error during decompression: {y}")\nif __name__=='__main__':AG()\n""")
